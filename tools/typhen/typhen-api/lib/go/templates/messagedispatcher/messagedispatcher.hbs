// This file was generated by typhen-api

package {{lowerCamelCase name}}

import (
	"{{@importBasePath}}/core"
	{{#each (realTimeMessageDispacherModules this)}}
	_{{alias}} "{{@importBasePath}}/messagedispatcher/{{path}}"
	{{/each}}
	{{#each (realTimeMessages types)}}
	{{#if @first}}
	{{namespace this '_'}} "{{@importBasePath}}/type/{{namespace this '/'}}"
	{{/if}}
	{{/each}}
)

// MessageDispatcher handles raw binary messages, and dispatches messages to sub handlers.
type MessageDispatcher struct {
	serializer   *typhenapi.Serializer
	errorHandler func([]byte, error)
	{{#each modules}}
	{{upperCamelCase name}} *_{{moduleName this '_'}}.MessageDispatcher
	{{/each}}

	{{#each (realTimeMessages types)}}
	{{upperCamelCase name}} func(message {{typeName this null false true}})
	{{/each}}
}

// New creates a MessageDispatcher.
func New(serializer *typhenapi.Serializer, errorHandler func([]byte, error)) *MessageDispatcher {
	d := &MessageDispatcher{}
	d.serializer = serializer
	d.errorHandler = errorHandler
	{{#each modules}}
	d.{{upperCamelCase name}} = _{{moduleName this '_'}}.New(serializer, errorHandler)
	{{/each}}
	return d
}

// HandleMessage handles a binary message.
func (d *MessageDispatcher) HandleMessage(data []byte) {
	{{#each modules}}
	d.{{upperCamelCase name}}.HandleMessage(data)
	{{/each}}

	{{#if (realTimeMessages types)}}
	message, err := typhenapi.NewMessageFromBytes(data)
	if err != nil {
		d.errorHandler(data, err)
		return
	}

	switch message.Type {
	{{#each (realTimeMessages types)}}
	case {{realTimeMessageType this}}:
		typhenType := new({{typeName this null false false}})
		if err := d.serializer.Deserialize(message.Body, typhenType); err != nil {
			d.errorHandler(data, err)
			return
		}

		if err := typhenType.Coerce(); err != nil {
			d.errorHandler(data, err)
			return
		}

		if d.{{upperCamelCase name}} != nil {
			d.{{upperCamelCase name}}(typhenType)
		}
	{{/each}}
	}
	{{/if}}
}
